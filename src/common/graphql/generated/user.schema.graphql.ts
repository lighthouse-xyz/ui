export type Maybe<T> = T;
export type InputMaybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  AkuChapterId: string;
  AkuQuestId: string;
  BlockchainAddress: string;
  DateTime: string;
  EntityId: string;
  EntityOrUserId: string;
  EstateId: string;
  JSONObject: Record<string, unknown>;
  ParcelId: string;
  URL: string;
  Upload: File;
  UserId: string;
};

export enum ActivityVerb {
  create = "create",
  follow = "follow",
  goLive = "goLive",
  interested = "interested",
}

export type AkuAnswerValidation = {
  __typename?: "AkuAnswerValidation";
  isAnswerValid: Scalars["Boolean"];
  questId: Scalars["AkuQuestId"];
};

export type AkuChapter = {
  __typename?: "AkuChapter";
  chapterName: AkuChapterName;
  quests: Array<AkuQuest>;
  status: AkuChapterStatus;
};

export enum AkuChapterName {
  ethDenver = "ethDenver",
  nftNyc = "nftNyc",
  nftParis = "nftParis",
}

export enum AkuChapterStatus {
  active = "active",
  expired = "expired",
  upcoming = "upcoming",
}

export type AkuQuest = {
  __typename?: "AkuQuest";
  answer?: Maybe<Scalars["String"]>;
  chapterId: Scalars["String"];
  day: Scalars["Int"];
  questId: Scalars["String"];
  question?: Maybe<Scalars["String"]>;
  type: AkuQuestType;
};

export enum AkuQuestType {
  extra = "extra",
  extraWithoutValidation = "extraWithoutValidation",
  main = "main",
}

export type AkuRegistrationResult = {
  __typename?: "AkuRegistrationResult";
  email: Scalars["String"];
};

export type ApiExtensionToken = {
  __typename?: "ApiExtensionToken";
  token: Scalars["String"];
  userId: Scalars["String"];
};

export type ApiProfileRole = {
  __typename?: "ApiProfileRole";
  roles: Array<Role>;
};

export type AppearOfflineInput = {
  appearOffline: Scalars["Boolean"];
};

export type AttendMvfwInput = {
  attendMvfw: Scalars["Boolean"];
};

export type AttendeeStatus = {
  __typename?: "AttendeeStatus";
  attendingMvfw: Scalars["Boolean"];
};

export type AvatarClaimedState = {
  __typename?: "AvatarClaimedState";
  avatarClaimedAt: Scalars["DateTime"];
  avatarType: ClaimAvatarType;
  avatarUrl: Scalars["URL"];
  userId: Scalars["UserId"];
};

export type BatchDeleteProfileInput = {
  userIds: Array<Scalars["UserId"]>;
};

export type BatchDeleteProfileReport = {
  __typename?: "BatchDeleteProfileReport";
  deletedIds: Array<Scalars["UserId"]>;
  missingIds: Array<Scalars["UserId"]>;
};

export enum ClaimAvatarType {
  avatarInviteClaimed = "avatarInviteClaimed",
  avatarOnboardingClaimed = "avatarOnboardingClaimed",
}

export type CreateAkuChapterInput = {
  chapterName: AkuChapterName;
  endDate: Scalars["DateTime"];
  startDate: Scalars["DateTime"];
};

export type CreateAkuQuestInput = {
  answer: Scalars["String"];
  chapterId: Scalars["String"];
  day: Scalars["Int"];
  question?: InputMaybe<Scalars["String"]>;
  type: AkuQuestType;
};

export type CreateEmptyProfileInput = {
  walletAddress: Scalars["BlockchainAddress"];
};

export enum Currency {
  eth = "eth",
  mana = "mana",
  sand = "sand",
}

export type DateTimeFilter = {
  greaterThan?: InputMaybe<Scalars["DateTime"]>;
  greaterThanOrEqual?: InputMaybe<Scalars["DateTime"]>;
  lessThan?: InputMaybe<Scalars["DateTime"]>;
  lessThanOrEqual?: InputMaybe<Scalars["DateTime"]>;
};

export type DeletedObject = {
  __typename?: "DeletedObject";
  entityId: Scalars["EntityOrUserId"];
};

export type EntityIdArgs = {
  entityId: Scalars["EntityId"];
};

export enum EntityType {
  estate = "estate",
  event = "event",
  member = "member",
  parcel = "parcel",
}

export type Estate = {
  __typename?: "Estate";
  /** `true` if the entity can be viewed in a marketplace; `false` otherwise. */
  canViewMarketplace: Scalars["Boolean"];
  /** The date and time that the entity was created. */
  createdAt?: Maybe<Scalars["DateTime"]>;
  currency?: Maybe<Currency>;
  /** Description of the entity. Max length: 5000 characters. */
  description?: Maybe<Scalars["String"]>;
  /** Unique identifier generated by Lighthouse. */
  entityId: Scalars["EntityOrUserId"];
  /** Used if the entity is featured on Lighthouse's [homepage](https://lighthouse.world/home). Gifs and slideshows that display dynamic content are recommended. Optimized for files under 5 MB. */
  featuredMedia?: Maybe<Scalars["URL"]>;
  fetchedAt: Scalars["DateTime"];
  /** Displayed when viewing the entity. Optimized for files under 5 MB. */
  image?: Maybe<Scalars["URL"]>;
  /** `true` if the entity is jumpable; `false` otherwise. */
  jumpable: Scalars["Boolean"];
  liked?: Maybe<Scalars["Boolean"]>;
  name?: Maybe<Scalars["String"]>;
  /** Wallet address of the entity owner. */
  owner?: Maybe<Scalars["BlockchainAddress"]>;
  /** Lighthouse user id of the entity owner. Either `owner` or `ownerUser` must be specified. */
  ownerUser?: Maybe<Scalars["UserId"]>;
  pinned?: Maybe<Scalars["Boolean"]>;
  price?: Maybe<Scalars["Float"]>;
  priceStatus?: Maybe<PriceStatus>;
  storedAt: Scalars["DateTime"];
  tags: Array<Scalars["String"]>;
  tokenUri?: Maybe<Scalars["URL"]>;
  /** Type of the entity. */
  type: EntityType;
  /** The date and time that the entity was updated. */
  updatedAt?: Maybe<Scalars["DateTime"]>;
  /** The world in which this entity can be found. */
  world: World;
  xCoordinate?: Maybe<Scalars["Float"]>;
  yCoordinate?: Maybe<Scalars["Float"]>;
};

/** An experience in the metaverse that is delimited in time. */
export type Event = {
  __typename?: "Event";
  /** List of categories that describe the entity. Max number of categories: 10. */
  categories: Array<EventCategory>;
  /** The date and time that the entity was created. */
  createdAt?: Maybe<Scalars["DateTime"]>;
  /** @deprecated Usage no longer enforced, access to events are based on owner only. */
  createdThroughLighthouse: Scalars["Boolean"];
  /** Description of the entity. Max length: 5000 characters. */
  description?: Maybe<Scalars["String"]>;
  /** Duration of the event in seconds, calculated from the `nextStartAt` and `nextFinishAt` fields. */
  durationInSeconds: Scalars["Float"];
  /** Unique identifier generated by Lighthouse. */
  entityId: Scalars["EntityOrUserId"];
  estateId?: Maybe<Scalars["EstateId"]>;
  /** Used if the entity is featured on Lighthouse's [homepage](https://lighthouse.world/home). Gifs and slideshows that display dynamic content are recommended. Optimized for files under 5 MB. */
  featuredMedia?: Maybe<Scalars["URL"]>;
  fetchedAt: Scalars["DateTime"];
  /** Displayed when viewing the entity. Optimized for files under 5 MB. */
  image?: Maybe<Scalars["URL"]>;
  initialStartAt?: Maybe<Scalars["DateTime"]>;
  interested?: Maybe<Scalars["Boolean"]>;
  isAllDay: Scalars["Boolean"];
  isRecurring: Scalars["Boolean"];
  /** `true` if the entity is jumpable; `false` otherwise. */
  jumpable: Scalars["Boolean"];
  latestFinishAt?: Maybe<Scalars["DateTime"]>;
  liked?: Maybe<Scalars["Boolean"]>;
  live: Scalars["Boolean"];
  /** Name of the entity. Max length: 100 characters. */
  name?: Maybe<Scalars["String"]>;
  /** The end of the event. */
  nextFinishAt: Scalars["DateTime"];
  /** The start of the event. */
  nextStartAt: Scalars["DateTime"];
  /** Wallet address of the entity owner. */
  owner?: Maybe<Scalars["BlockchainAddress"]>;
  /** Lighthouse user id of the entity owner. Either `owner` or `ownerUser` must be specified. */
  ownerUser?: Maybe<Scalars["UserId"]>;
  /** Lighthouse parcel id specifying the location of the event. */
  parcelId?: Maybe<Scalars["ParcelId"]>;
  past: Scalars["Boolean"];
  pinned?: Maybe<Scalars["Boolean"]>;
  storedAt: Scalars["DateTime"];
  /** List of tags that describe the entity. Max number of tags: 10. Max tag length: 20 characters. */
  tags: Array<Scalars["String"]>;
  totalAttendees?: Maybe<Scalars["Float"]>;
  /** Type of the entity. */
  type: EntityType;
  /** The date and time that the entity was updated. */
  updatedAt?: Maybe<Scalars["DateTime"]>;
  /** The location of the entity. */
  url?: Maybe<Scalars["URL"]>;
  /** The world in which this entity can be found. */
  world: World;
  xCoordinate?: Maybe<Scalars["Float"]>;
  yCoordinate?: Maybe<Scalars["Float"]>;
};

export enum EventCategory {
  artExhibition = "artExhibition",
  brandLaunch = "brandLaunch",
  competition = "competition",
  conference = "conference",
  fundraising = "fundraising",
  giveaway = "giveaway",
  hangout = "hangout",
  livePerformance = "livePerformance",
  music = "music",
  mvfw = "mvfw",
  networking = "networking",
  party = "party",
  playToEarn = "playToEarn",
  socialActivity = "socialActivity",
  sport = "sport",
  talkPresentation = "talkPresentation",
  workshopLecture = "workshopLecture",
}

export type FollowInput = {
  targetUserId: Scalars["UserId"];
};

export type FollowRelationship = {
  __typename?: "FollowRelationship";
  currentUser: Profile;
  targetUser: Profile;
};

export enum FollowingStatus {
  follower = "follower",
  following = "following",
  friend = "friend",
  none = "none",
  self = "self",
}

export enum FriendListSortingMethod {
  alias = "alias",
  date = "date",
  isInWorld = "isInWorld",
  isOnline = "isOnline",
}

export type InterestedFilteringArgs = {
  nextFinishAt?: InputMaybe<DateTimeFilter>;
  nextStartAt?: InputMaybe<DateTimeFilter>;
};

export enum InterestedSortingMethod {
  nextFinishAtAsc = "nextFinishAtAsc",
  nextFinishAtDesc = "nextFinishAtDesc",
  nextStartAtAsc = "nextStartAtAsc",
  nextStartAtDesc = "nextStartAtDesc",
}

export type InviteLink = {
  __typename?: "InviteLink";
  url: Scalars["URL"];
};

export type JumpLog = {
  __typename?: "JumpLog";
  entity: JumpableEntity;
  lastJumpDate: Scalars["DateTime"];
};

export type JumpToUserLocation = {
  __typename?: "JumpToUserLocation";
  url: Scalars["URL"];
};

export type JumpableEntity = Estate | Event | Parcel;

export type LightkeeperLeaderboardFilteringArgs = {
  payPeriodStartAt?: InputMaybe<Scalars["DateTime"]>;
};

export type LightkeeperPayPeriods = {
  __typename?: "LightkeeperPayPeriods";
  payPeriods: Array<Scalars["DateTime"]>;
};

export type LightkeeperStatsSummary = {
  __typename?: "LightkeeperStatsSummary";
  dollarsEarned: Scalars["Float"];
  lastUpdatedAt: Scalars["DateTime"];
  lightkeeper: Profile;
  pointsEarned: Scalars["Int"];
  rank: Scalars["Int"];
  usersReferred: Scalars["Int"];
};

export type LightkeeperStatsSummaryFilteringArgs = {
  payPeriodStartAt?: InputMaybe<Scalars["DateTime"]>;
};

export type LikableEntity = Estate | Event | Parcel;

export type LocationInput = {
  location: Scalars["URL"];
};

export enum LocationSharingType {
  allUsers = "allUsers",
  friends = "friends",
  friendsAndFollowers = "friendsAndFollowers",
}

export type LocationStatus = {
  __typename?: "LocationStatus";
  activatePublicLink: Scalars["Boolean"];
  allowsSharingLocation: Scalars["Boolean"];
  lastLocation?: Maybe<UserLocation>;
  locationSharingType: LocationSharingType;
};

export type LogJumpInput = {
  entityId?: InputMaybe<Scalars["EntityId"]>;
  jumpedToUserId?: InputMaybe<Scalars["UserId"]>;
  url?: InputMaybe<Scalars["URL"]>;
};

export type LogoutFromExtensionResult = {
  __typename?: "LogoutFromExtensionResult";
  tokensFlushed: Scalars["Int"];
};

export type MediaArea = {
  height: Scalars["Int"];
  left: Scalars["Int"];
  top: Scalars["Int"];
  width: Scalars["Int"];
};

export type MergeProfilesInput = {
  sourceUserId: Scalars["UserId"];
};

export type Mutation = {
  __typename?: "Mutation";
  appearOffline: Status;
  attendMvfw: AttendeeStatus;
  batchDeleteProfile: BatchDeleteProfileReport;
  createAkuChapter: AkuChapter;
  createAkuQuest: AkuQuest;
  createEmptyProfile: Profile;
  deleteAkuChapter: AkuChapter;
  deleteAkuQuest: AkuQuest;
  deleteProfile: Profile;
  deleteProfileBanner: Profile;
  deleteProfilePicture: Profile;
  follow: FollowRelationship;
  generateExtensionToken: ApiExtensionToken;
  getUserShareableJumpUrl: JumpToUserLocation;
  grantAdminRole: RoleRelationship;
  interestedInEvent: UserEntityRelationship;
  likeEntity: UserEntityRelationship;
  logJump: UserEntityJumpRelationship;
  logoutFromExtension: LogoutFromExtensionResult;
  mergeProfiles: Profile;
  pinEntity: UserEntityRelationship;
  registerToAku: AkuRegistrationResult;
  report: ReportMessage;
  reportLiveStatus: Status;
  requestDeleteProfile: Profile;
  revokeAdminRole: RoleRelationship;
  setUserState: UserState;
  touchProfile: TouchProfileData;
  trackUserLocation: TrackUserLocation;
  unfollow: FollowRelationship;
  uninterestedInEvent: UserEntityRelationship;
  unlikeEntity: UserEntityRelationship;
  unpinEntity: UserEntityRelationship;
  updateAkuChapter: AkuChapter;
  updateAkuQuest: AkuQuest;
  updateCustomStatus: Status;
  updateLocationStatus: LocationStatus;
  updateNotificationSettings: NotificationSettings;
  updateProfile: Profile;
  updateProfileBannerFromNft: Profile;
  updateProfileBannerFromUrl: Profile;
  updateProfileMediaFromFile: Profile;
  updateProfilePictureFromNft: Profile;
  updateProfilePictureFromUrl: Profile;
  validateAkuAnswer: AkuAnswerValidation;
};

export type MutationAppearOfflineArgs = {
  input: AppearOfflineInput;
  userId: Scalars["UserId"];
};

export type MutationAttendMvfwArgs = {
  input: AttendMvfwInput;
  userId: Scalars["UserId"];
};

export type MutationBatchDeleteProfileArgs = {
  input: BatchDeleteProfileInput;
};

export type MutationCreateAkuChapterArgs = {
  input: CreateAkuChapterInput;
};

export type MutationCreateAkuQuestArgs = {
  input: CreateAkuQuestInput;
};

export type MutationCreateEmptyProfileArgs = {
  input: CreateEmptyProfileInput;
};

export type MutationDeleteAkuChapterArgs = {
  chapterId: Scalars["AkuChapterId"];
};

export type MutationDeleteAkuQuestArgs = {
  questId: Scalars["AkuQuestId"];
};

export type MutationDeleteProfileArgs = {
  userId: Scalars["UserId"];
};

export type MutationDeleteProfileBannerArgs = {
  userId: Scalars["UserId"];
};

export type MutationDeleteProfilePictureArgs = {
  userId: Scalars["UserId"];
};

export type MutationFollowArgs = {
  input: FollowInput;
  userId: Scalars["UserId"];
};

export type MutationGetUserShareableJumpUrlArgs = {
  userId: Scalars["UserId"];
};

export type MutationGrantAdminRoleArgs = {
  userId: Scalars["UserId"];
};

export type MutationInterestedInEventArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationLikeEntityArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationLogJumpArgs = {
  input: LogJumpInput;
  userId: Scalars["UserId"];
};

export type MutationMergeProfilesArgs = {
  input: MergeProfilesInput;
  userId: Scalars["UserId"];
};

export type MutationPinEntityArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationRegisterToAkuArgs = {
  input: RegisterToAkuInput;
};

export type MutationReportArgs = {
  entityId: Scalars["EntityOrUserId"];
  input: ReportInput;
};

export type MutationReportLiveStatusArgs = {
  userId: Scalars["UserId"];
};

export type MutationRequestDeleteProfileArgs = {
  userId: Scalars["UserId"];
};

export type MutationRevokeAdminRoleArgs = {
  userId: Scalars["UserId"];
};

export type MutationSetUserStateArgs = {
  input: SetUserStateInput;
  userId: Scalars["UserId"];
};

export type MutationTouchProfileArgs = {
  input: Scalars["JSONObject"];
  userId: Scalars["UserId"];
};

export type MutationTrackUserLocationArgs = {
  input: LocationInput;
  userId: Scalars["UserId"];
};

export type MutationUnfollowArgs = {
  input: FollowInput;
  userId: Scalars["UserId"];
};

export type MutationUninterestedInEventArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationUnlikeEntityArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationUnpinEntityArgs = {
  input: EntityIdArgs;
  userId: Scalars["UserId"];
};

export type MutationUpdateAkuChapterArgs = {
  chapterId: Scalars["AkuChapterId"];
  input: UpdateAkuChapterInput;
};

export type MutationUpdateAkuQuestArgs = {
  input: UpdateAkuQuestInput;
  questId: Scalars["AkuQuestId"];
};

export type MutationUpdateCustomStatusArgs = {
  input: UpdateCustomStatusInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateLocationStatusArgs = {
  input: UpdateLocationStatusInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateNotificationSettingsArgs = {
  input: NotificationSettingsInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfileArgs = {
  input: UpdateProfileInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfileBannerFromNftArgs = {
  input: UpdatePictureFromNftInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfileBannerFromUrlArgs = {
  input: UpdatePictureFromUrlInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfileMediaFromFileArgs = {
  input: UpdateProfileMediaFromFileInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfilePictureFromNftArgs = {
  input: UpdatePictureFromNftInput;
  userId: Scalars["UserId"];
};

export type MutationUpdateProfilePictureFromUrlArgs = {
  input: UpdatePictureFromUrlInput;
  userId: Scalars["UserId"];
};

export type MutationValidateAkuAnswerArgs = {
  input: ValidateAkuAnswerInput;
  userId: Scalars["UserId"];
};

export type Notification = {
  __typename?: "Notification";
  activityId: Scalars["String"];
  actor: NotificationActor;
  id: Scalars["String"];
  isRead: Scalars["Boolean"];
  isSeen: Scalars["Boolean"];
  object: NotificationObject;
  time: Scalars["DateTime"];
  verb: ActivityVerb;
};

export type NotificationActor = DeletedObject | Event | Profile;

export type NotificationObject = DeletedObject | Estate | Event | Parcel | Profile;

export type NotificationSettings = {
  __typename?: "NotificationSettings";
  eventGoLive: Scalars["Boolean"];
  follow: Scalars["Boolean"];
  followingActivity: Scalars["Boolean"];
  friendActivity: Scalars["Boolean"];
  ownedEntity: Scalars["Boolean"];
};

export type NotificationSettingsInput = {
  eventGoLive?: InputMaybe<Scalars["Boolean"]>;
  follow?: InputMaybe<Scalars["Boolean"]>;
  followingActivity?: InputMaybe<Scalars["Boolean"]>;
  friendActivity?: InputMaybe<Scalars["Boolean"]>;
  ownedEntity?: InputMaybe<Scalars["Boolean"]>;
};

export type NotificationsStatus = {
  __typename?: "NotificationsStatus";
  hasUnseenNotifications: Scalars["Boolean"];
};

export type NotificationsToken = {
  __typename?: "NotificationsToken";
  token: Scalars["String"];
};

export type OnboardingStatus = {
  __typename?: "OnboardingStatus";
  stepsUncompleted: Scalars["Int"];
};

export type PageInfo = {
  __typename?: "PageInfo";
  hasNextPage: Scalars["Boolean"];
};

export type PaginatedInterested = {
  __typename?: "PaginatedInterested";
  nodes?: Maybe<Array<Event>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedJumpLogs = {
  __typename?: "PaginatedJumpLogs";
  nodes?: Maybe<Array<JumpLog>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedLightkeeperStatsSummaries = {
  __typename?: "PaginatedLightkeeperStatsSummaries";
  lastUpdatedAt: Scalars["DateTime"];
  nodes?: Maybe<Array<LightkeeperStatsSummary>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedLikes = {
  __typename?: "PaginatedLikes";
  nodes?: Maybe<Array<LikableEntity>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedNotifications = {
  __typename?: "PaginatedNotifications";
  nodes?: Maybe<Array<Notification>>;
  pageInfo: PageInfo;
};

export type PaginatedPins = {
  __typename?: "PaginatedPins";
  nodes?: Maybe<Array<PinnableEntity>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedProfiles = {
  __typename?: "PaginatedProfiles";
  nodes?: Maybe<Array<Profile>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type PaginatedReferredUserStats = {
  __typename?: "PaginatedReferredUserStats";
  nodes?: Maybe<Array<ReferredUserStats>>;
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** A digital space in the metaverse. */
export type Parcel = {
  __typename?: "Parcel";
  /** `true` if the entity can be viewed in a marketplace; `false` otherwise. */
  canViewMarketplace: Scalars["Boolean"];
  /** List of categories that describe the entity. Max number of categories: 10. */
  categories: Array<ParcelCategory>;
  /** The date and time that the entity was created. */
  createdAt?: Maybe<Scalars["DateTime"]>;
  /** @deprecated Usage no longer enforced, access to parcels are based on owner only. */
  createdThroughLighthouse: Scalars["Boolean"];
  currency?: Maybe<Currency>;
  /** Description of the entity. Max length: 5000 characters. */
  description?: Maybe<Scalars["String"]>;
  /** Unique identifier generated by Lighthouse. */
  entityId: Scalars["EntityOrUserId"];
  estateId?: Maybe<Scalars["EstateId"]>;
  /** Used if the entity is featured on Lighthouse's [homepage](https://lighthouse.world/home). Gifs and slideshows that display dynamic content are recommended. Optimized for files under 5 MB. */
  featuredMedia?: Maybe<Scalars["URL"]>;
  fetchedAt: Scalars["DateTime"];
  /** Displayed when viewing the entity. Optimized for files under 5 MB. */
  image?: Maybe<Scalars["URL"]>;
  /** `true` if the entity is jumpable; `false` otherwise. */
  jumpable: Scalars["Boolean"];
  liked?: Maybe<Scalars["Boolean"]>;
  name?: Maybe<Scalars["String"]>;
  /** Wallet address of the entity owner. */
  owner?: Maybe<Scalars["BlockchainAddress"]>;
  /** Lighthouse user id of the entity owner. Either `owner` or `ownerUser` must be specified. */
  ownerUser?: Maybe<Scalars["UserId"]>;
  pinned?: Maybe<Scalars["Boolean"]>;
  price?: Maybe<Scalars["Float"]>;
  priceStatus?: Maybe<PriceStatus>;
  storedAt: Scalars["DateTime"];
  /** List of tags that describe the entity. Max number of tags: 10. Max tag length: 20 characters. */
  tags: Array<Scalars["String"]>;
  tokenUri?: Maybe<Scalars["URL"]>;
  /** Type of the entity. */
  type: EntityType;
  /** The date and time that the entity was updated. */
  updatedAt?: Maybe<Scalars["DateTime"]>;
  /** The location of the entity. */
  url?: Maybe<Scalars["String"]>;
  /** The world in which this entity can be found. */
  world: World;
  xCoordinate?: Maybe<Scalars["Float"]>;
  yCoordinate?: Maybe<Scalars["Float"]>;
};

export enum ParcelCategory {
  art = "art",
  education = "education",
  gaming = "gaming",
  mvfw = "mvfw",
  services = "services",
  shopping = "shopping",
  social = "social",
  work = "work",
}

export type PinnableEntity = Estate | Event | Parcel;

export enum PriceStatus {
  cancelled = "cancelled",
  open = "open",
  sold = "sold",
}

export type Profile = {
  __typename?: "Profile";
  alias?: Maybe<Scalars["String"]>;
  attendingMvfw: Scalars["Boolean"];
  banner?: Maybe<Scalars["URL"]>;
  category: UserCategory;
  createdAt: Scalars["DateTime"];
  customStatus?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  discord?: Maybe<Scalars["URL"]>;
  discordUsername?: Maybe<Scalars["String"]>;
  followerCount: Scalars["Int"];
  followingCount: Scalars["Int"];
  followingStatus?: Maybe<FollowingStatus>;
  friendCount: Scalars["Int"];
  handle?: Maybe<Scalars["String"]>;
  instagram?: Maybe<Scalars["URL"]>;
  isOnline: Scalars["Boolean"];
  location?: Maybe<UserLocation>;
  medium?: Maybe<Scalars["URL"]>;
  mirror?: Maybe<Scalars["URL"]>;
  notificationSettings?: Maybe<NotificationSettings>;
  picture?: Maybe<Scalars["URL"]>;
  tags: Array<Scalars["String"]>;
  twitter?: Maybe<Scalars["URL"]>;
  updatedAt: Scalars["DateTime"];
  userId: Scalars["String"];
  walletAddress?: Maybe<Scalars["BlockchainAddress"]>;
  website?: Maybe<Scalars["URL"]>;
};

export type Query = {
  __typename?: "Query";
  akuChapter: AkuChapter;
  claimAndGetAvatar: AvatarClaimedState;
  facebookInvite: InviteLink;
  followerRecommendations: PaginatedProfiles;
  followers: PaginatedProfiles;
  following: PaginatedProfiles;
  friends: PaginatedProfiles;
  helloWorld: Scalars["String"];
  interested: PaginatedInterested;
  jumpHistory: PaginatedJumpLogs;
  lightkeeperLeaderboard: PaginatedLightkeeperStatsSummaries;
  lightkeeperPayPeriods: LightkeeperPayPeriods;
  lightkeeperStatsSummary: LightkeeperStatsSummary;
  likes: PaginatedLikes;
  locationStatus: LocationStatus;
  mvfwAttendees: PaginatedProfiles;
  notifications: PaginatedNotifications;
  notificationsStatus: NotificationsStatus;
  notificationsToken: NotificationsToken;
  openInvites: PaginatedProfiles;
  pins: PaginatedPins;
  profile: Profile;
  profileFromToken: Profile;
  profileRolesFromToken: ApiProfileRole;
  redditInvite: InviteLink;
  referredUserStats: PaginatedReferredUserStats;
  status: Status;
  telegramInvite: InviteLink;
  twitterInvite: InviteLink;
  userOnboardingState: UserOnboardingState;
  userState: UserState;
};

export type QueryAkuChapterArgs = {
  chapterName: AkuChapterName;
};

export type QueryClaimAndGetAvatarArgs = {
  step: ClaimAvatarType;
  userId: Scalars["UserId"];
};

export type QueryFollowerRecommendationsArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
};

export type QueryFollowersArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  sortBy?: InputMaybe<RelationListSortingMethod>;
  userId: Scalars["UserId"];
};

export type QueryFollowingArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  sortBy?: InputMaybe<RelationListSortingMethod>;
  userId: Scalars["UserId"];
};

export type QueryFriendsArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  sortBy?: InputMaybe<FriendListSortingMethod>;
  userId: Scalars["UserId"];
};

export type QueryInterestedArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  sortBy?: InputMaybe<InterestedSortingMethod>;
  userId: Scalars["UserId"];
  where?: InputMaybe<InterestedFilteringArgs>;
};

export type QueryJumpHistoryArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
};

export type QueryLightkeeperLeaderboardArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<LightkeeperLeaderboardFilteringArgs>;
};

export type QueryLightkeeperPayPeriodsArgs = {
  userId: Scalars["UserId"];
};

export type QueryLightkeeperStatsSummaryArgs = {
  userId: Scalars["UserId"];
  where?: InputMaybe<LightkeeperStatsSummaryFilteringArgs>;
};

export type QueryLikesArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
};

export type QueryLocationStatusArgs = {
  userId: Scalars["UserId"];
};

export type QueryMvfwAttendeesArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId?: InputMaybe<Scalars["UserId"]>;
};

export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars["String"]>;
  first?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
};

export type QueryNotificationsStatusArgs = {
  userId: Scalars["UserId"];
};

export type QueryPinsArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
};

export type QueryProfileArgs = {
  handle?: InputMaybe<Scalars["String"]>;
  userId?: InputMaybe<Scalars["UserId"]>;
};

export type QueryProfileFromTokenArgs = {
  isLogin?: InputMaybe<Scalars["Boolean"]>;
};

export type QueryReferredUserStatsArgs = {
  first?: InputMaybe<Scalars["Int"]>;
  offset?: InputMaybe<Scalars["Int"]>;
  userId: Scalars["UserId"];
  where?: InputMaybe<ReferredUserStatsFilteringArgs>;
};

export type QueryStatusArgs = {
  userId: Scalars["UserId"];
};

export type QueryUserOnboardingStateArgs = {
  userId: Scalars["UserId"];
};

export type QueryUserStateArgs = {
  userId: Scalars["UserId"];
};

export type ReferredUserStats = {
  __typename?: "ReferredUserStats";
  cameBack: Scalars["Boolean"];
  daysLeft: Scalars["Int"];
  dollarsEarned: Scalars["Float"];
  extensionLogin: Scalars["Boolean"];
  followedOtherUsers: Scalars["Boolean"];
  jumpedToOtherUsers: Scalars["Boolean"];
  personalizedGate: Scalars["Boolean"];
  pointsEarned: Scalars["Int"];
  profile: Profile;
  progress: Scalars["Float"];
};

export type ReferredUserStatsFilteringArgs = {
  payPeriodStartAt?: InputMaybe<Scalars["DateTime"]>;
};

export type RegisterToAkuInput = {
  email: Scalars["String"];
  subscribeToNewsletter: Scalars["Boolean"];
};

export enum RelationListSortingMethod {
  alias = "alias",
  date = "date",
  isInWorld = "isInWorld",
  isOnline = "isOnline",
}

export type ReportInput = {
  description: Scalars["String"];
};

export type ReportMessage = {
  __typename?: "ReportMessage";
  message: Scalars["String"];
};

export enum Role {
  admin = "admin",
  dev = "dev",
  lightkeeper = "lightkeeper",
}

export type RoleRelationship = {
  __typename?: "RoleRelationship";
  createdAt: Scalars["DateTime"];
  roles: Array<Role>;
  updatedAt: Scalars["DateTime"];
  userId: Scalars["UserId"];
};

export type SetUserStateInput = {
  frontendState?: InputMaybe<Scalars["JSONObject"]>;
  onboardingCompleted?: InputMaybe<Scalars["Boolean"]>;
};

export type Status = {
  __typename?: "Status";
  appearOffline: Scalars["Boolean"];
  customStatus?: Maybe<Scalars["String"]>;
  customStatusExpiresAt?: Maybe<Scalars["DateTime"]>;
  isOnline: Scalars["Boolean"];
};

export type Subscription = {
  __typename?: "Subscription";
  onboardingStateUpdated: OnboardingStatus;
};

export type SubscriptionOnboardingStateUpdatedArgs = {
  userId: Scalars["UserId"];
};

export type TouchProfileData = {
  __typename?: "TouchProfileData";
  metadata: Scalars["JSONObject"];
  userId: Scalars["String"];
};

export type TrackUserLocation = {
  __typename?: "TrackUserLocation";
  url?: Maybe<Scalars["URL"]>;
  world?: Maybe<World>;
};

export type UpdateAkuChapterInput = {
  chapterName: AkuChapterName;
  endDate: Scalars["DateTime"];
  startDate: Scalars["DateTime"];
};

export type UpdateAkuQuestInput = {
  answer?: InputMaybe<Scalars["String"]>;
  day?: InputMaybe<Scalars["Int"]>;
  question?: InputMaybe<Scalars["String"]>;
  type?: InputMaybe<AkuQuestType>;
};

export type UpdateCustomStatusInput = {
  customStatus?: InputMaybe<Scalars["String"]>;
  customStatusExpiresAt?: InputMaybe<Scalars["DateTime"]>;
};

export type UpdateLocationStatusInput = {
  activatePublicLink?: InputMaybe<Scalars["Boolean"]>;
  allowsSharingLocation?: InputMaybe<Scalars["Boolean"]>;
  locationSharingType?: InputMaybe<LocationSharingType>;
};

export type UpdateMediaFromFileInput = {
  cropArea?: InputMaybe<MediaArea>;
  file: Scalars["Upload"];
};

export type UpdatePictureFromNftInput = {
  contractAddress: Scalars["String"];
  cropArea?: InputMaybe<MediaArea>;
  tokenId: Scalars["String"];
};

export type UpdatePictureFromUrlInput = {
  url: Scalars["String"];
};

export type UpdateProfileInput = {
  alias?: InputMaybe<Scalars["String"]>;
  category?: InputMaybe<UserCategory>;
  description?: InputMaybe<Scalars["String"]>;
  discord?: InputMaybe<Scalars["URL"]>;
  discordUsername?: InputMaybe<Scalars["String"]>;
  handle?: InputMaybe<Scalars["String"]>;
  instagram?: InputMaybe<Scalars["URL"]>;
  medium?: InputMaybe<Scalars["URL"]>;
  mirror?: InputMaybe<Scalars["URL"]>;
  tags?: InputMaybe<Array<Scalars["String"]>>;
  twitter?: InputMaybe<Scalars["URL"]>;
  website?: InputMaybe<Scalars["URL"]>;
};

export type UpdateProfileMediaFromFileInput = {
  banner?: InputMaybe<UpdateMediaFromFileInput>;
  picture?: InputMaybe<UpdateMediaFromFileInput>;
};

export enum UserCategory {
  brand = "brand",
  creator = "creator",
  explorer = "explorer",
  lightkeeper = "lightkeeper",
}

export type UserEntityJumpRelationship = {
  __typename?: "UserEntityJumpRelationship";
  entityId?: Maybe<Scalars["EntityOrUserId"]>;
  jumpedToUserId?: Maybe<Scalars["UserId"]>;
  url?: Maybe<Scalars["URL"]>;
  userId: Scalars["UserId"];
};

export type UserEntityRelationship = {
  __typename?: "UserEntityRelationship";
  entityId: Scalars["EntityOrUserId"];
  userId: Scalars["UserId"];
};

export type UserLocation = {
  __typename?: "UserLocation";
  lastSeenAt: Scalars["DateTime"];
  url: Scalars["URL"];
  world: World;
};

export type UserOnboardingState = {
  __typename?: "UserOnboardingState";
  avatarInviteClaimedAt?: Maybe<Scalars["DateTime"]>;
  avatarOnboardingClaimedAt?: Maybe<Scalars["DateTime"]>;
  stepExtensionInstallAt?: Maybe<Scalars["DateTime"]>;
  stepGateModifAt?: Maybe<Scalars["DateTime"]>;
  stepInviteFriendAt?: Maybe<Scalars["DateTime"]>;
  stepPinAt?: Maybe<Scalars["DateTime"]>;
  userId: Scalars["UserId"];
};

export type UserState = {
  __typename?: "UserState";
  frontendState: Scalars["JSONObject"];
  onboardingCompleted: Scalars["Boolean"];
};

export type ValidateAkuAnswerInput = {
  answer: Scalars["String"];
  questId: Scalars["AkuQuestId"];
};

export enum World {
  arium = "arium",
  artifexUnreal = "artifexUnreal",
  astra = "astra",
  createra = "createra",
  decentraland = "decentraland",
  ethereal = "ethereal",
  hiberWorld = "hiberWorld",
  hyperfy = "hyperfy",
  janusXr = "janusXr",
  lvcidia = "lvcidia",
  mona = "mona",
  mozillaHubs = "mozillaHubs",
  muse = "muse",
  onCyber = "onCyber",
  portals = "portals",
  protoworld = "protoworld",
  rareRooms = "rareRooms",
  ronday = "ronday",
  rove = "rove",
  simulacra = "simulacra",
  somniumSpace = "somniumSpace",
  sougen = "sougen",
  soutsideCity = "soutsideCity",
  spatial = "spatial",
  substrata = "substrata",
  swivelMeta = "swivelMeta",
  theNemesis = "theNemesis",
  theSandbox = "theSandbox",
  tz1and = "tz1and",
  vesta = "vesta",
  viverse = "viverse",
  voxels = "voxels",
  vrChat = "vrChat",
  w3rlds = "w3rlds",
  webaverse = "webaverse",
}
